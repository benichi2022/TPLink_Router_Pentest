 
Figure 1: Credits to @d1gitalandrew on Twitter
Heads Up
Due to the vast threat landscape of the IoT ecosystem, this security assessment will focus primarily on the firmware. Reconnaissance on other attack surfaces, such as the hardware, web and networks, may be explored in a limited fashion. Its also worth mentioning this assessment in part is based on the course “Beginner’s Guide to IoT and Hardware Hacking” on TCM Security
Tools and Equipment
Target: TP-Link WR841NV14 Wireless Router
Flash ROM Programmer: ch341a USB Programmer
Programs: flashrom, Ghidra, CyberChef, openssl
OS: Kali Linux
Router FCCID: 2AXJ4WR841NV14
 
Figure 2: WR841NV14 Backside
Initial Recon and OSINT
Hardware OSINT via FCC ID
FCCID: 2AXJ4WR841NV14
An OSINT (Open-Source Intelligence) search for router information based on its FCCID - https://www.fcc.gov/oet/ea/fccid
Note – FCC ID is a unique ID assigned to devices that emit any wireless signal for communications, such as Wi-Fi, NFC, RFID, etc. Federal Communications Commission is the regulatory body in the US that assigns FCCID upon ensuring compliance by the device of interest. The equivalent of the FCC (Federal Communications Commission) is the Telecommunications and Digital Government Regulatory Authority (TDRA) in the UAE.
 
Figure 3: First Exhibits Returned

There are a few exhibits returned.
Opening the first documents shows the following – hints change in FCCID. The other documents show general information and images.
 
Figure 4: Change in FCCID

Let’s do a new FCCID search based on the new one, i.e. TE7WR841NV14
 
Figure 5: Exhibits returned based on the new FCCID
The new search returns even more files. Let’s have a look at them.
Link to the exhibits: https://apps.fcc.gov/oetcf/eas/reports/ViewExhibitReport.cfm?mode=Exhibits&RequestTimeout=500&calledFromFrame=N&application_id=JZP1lPBDkO4AIrblBlQ3Mg%3D%3D&fcc_id=TE7WR841NV14
Going through the internal photos document reveals available surface-mounted chips. This information may come in handy down the road. See the images below.
 
Without opening our router, we can identify crucial components within it. We can further look for their documentation online, although some details are confidential as they are proprietary technology.
 
Figure 6: Non-disclosure of Proprietary Property
Datasheet Lookup
CPU – MEDIATEK MT7628NN 
 MIPS architecture
 
Figure 7: CPU Info
https://files.seeedstudio.com/products/114992470/MT7628_datasheet.pdf
RAM - Zentel A3556D40GTP -50L 
We are not going to be concerned with in-memory attacks.
ROM – cfeon q32b-104hip 
The ROM uses SPI for communication based on the information in the datasheet below. 
https://www.alldatasheet.com/datasheet-pdf/pdf/458184/EON/EN25Q32B-104HIP.html
EN25QH32B JEDEC Serial Flash Memory Device 
 
Figure 8: Important to connect the flash programmer when extracting the firmware

Network Scanning
Open TCP ports
 
Figure 9: Nmap TCP Ports Scanning of the Router 
TCP ports 22/ssh, 80/http and 1900/UPnP are open. Further enumeration and various attacks such as brute-forcing, credential stuffing or using Proof-of-Concept exploits based on known CVEs can be launched. However, these are not within our scope for now.
Open UDP Ports
 
Figure 10: Nmap UDP Ports Scanning of the Router
Several UDP ports are in open/filtered state
Exploitation
Firmware Extraction
 
Figure 11: Ready to extract firmware using CH341A USB flash programmer

 
Figure 12: USB of the Flash Programmer Correctly Connected
On Kali Linux, the flashrom command line program can do various operations on the ROM such as read, write, erase etc. The following displays the manual on how to use it.
 
Figure 13: flashrom  Manual
As identified earlier, the id of ROM onboard chip is EN25QH32B, which uses SPI for communication. The following command extracts the firmware from the ROM within a few minutes.
 
Figure 14: Firmware Read from ROM
The firmware is written to this file - tp_link_wr841n_extracted_firmware.bin
Let’s move on to its analysis
Firmware Analysis
Let’s run a simple but very important command – strings – to show us strings that may make sense. Although if there are encrypted or compressed contents, output may appear gibberish. The boot loader does not seem to be encrypted hence we can see intelligible characters printed.
 
Figure 15: Running strings command on the firmware
The strings command returns some output, which might give us situational awareness. In the screenshot above, we can see the setup at boot time.
 
Figure 16: Constituents of Firmware
The firmware is a binary. Before splitting it to its sections, binwalk will give us an idea about what the firmware typically consists of. The U-Boot loads the kernel which appears LZMA compressed in Figure 16. Squashfs is an important filesystem for embedded systems.

 
Figure 17: Checking Entropy for Encryption or Compression
The rise in entropy, which means increased randomness, indicates either the section is encrypted or compressed. As noted in Figure 16, the kernel and the root filesystem are compressed using LZMA and XZ. Hence, their entropy is high. Let’s move onto the extraction with the help of binwalk.
The command for extraction – binwalk -e firmware.bin
 
Figure 18: Extracted Section by binwalk
Binwalk will name the files using the starting address by default.
 
Figure 19: Details about the filesystem – squashfs
Binwalk was able to identify the filesystem and uncompressed it recursively. We can also make sure there is no difference between the squashfs-root folders using diff. Although, our focus is on interesting binaries in the root filesystem, let’s investigate the other extracted file namely – 10200. As seen earlier, it represents the LZMA compressed Linux kernel. The Linux kernel is open source, so we don’t need to reverse engineer it. Let’s do some sanity check.
 
Figure 20: Kernel Information
Back to enumerating the filesystem.
 
Figure 21: Enumeration of the Root FileSystem
Enumerating a filesystem can be very extensive. Normally after landing on a Linux system, it is common to look in the /etc directory for configurations used for setting up the device or hosting crucial credentials. If we look closely, we see two xml files which might contain some configurations. Let’s look at default_config.xml
 
Figure 22: The xml file seems encrypted
As the content of the file seem encrypted, it’s time to investigate which library is responsible for encrypting it and what encryption method it is using. It can be done by using grep command which looks for the filename (assuming it is passed as a parameter) in each shared library. Look the screenshot below.
 
Figure 23: Libccm.so - object file responsible for encryption

Reverse Engineering
Reverse engineering is the process of analysing a system to understand its design, functionality, or behaviour. This is often done by deconstructing hardware, software, or other products to discover how they work, extract information about their components, or replicate their functionality.
For this purpose, we will use a famous tool known as Ghidra. A project, tp_link_wr841n, is created and the identified shared object file, libcmm.so, is imported into the project. The following is the import summary.
 
Figure 24: Import libcmm.so into Ghidra project

 
Figure 25: Analysis Done by Ghidra

Ghidra has done the analysis automatically. There are different sections as seen above. It’s good to start from the magic number “ELF” which indicated the type of the loaded binary, in this case is an Executable and Linking Format file. If we click on any section of the machine code, Ghidra will display its equivalent decompiled code in right-most windows. See below.
 
Figure 26: A section of decompiled code
Therefore, in our quest to figure out the cryptographic algorithm and decryption key, we will need to identify the section of the file that handles this functionality. Let’s start by searching for the keyword decrypt. Searching strings is a crucial feature of Ghidra.
 
Figure 27: Examining dm_decryptFile function
In the Figure 27, we first searched for the keyword “decrypt”. A few hits returned. “dm_decryptFile” function is selected for analysis. The machine code and the decompiled C code of the function are listed in Listing and Decompile sections, respectively. Now, let’s dig deeper to comprehend how the function works, what encryption algorithm is in use and what the decryption key is. From Figure 27, we can see a string “DES decrypt error” giving us an important hint that encryption algorithm used is The Data Encryption Standard (DES) - a symmetric-key block cipher used for encrypting and decrypting data. It operates on a block size of 64 bits and uses a 56-bit key (plus 8 parity bits). Having in mind that the key is 64-bit size, let’s investigate the decompiled code.
 
Figure 28: auStack_28 seems the decryption key?
Note: Since the DES is a symmetric cryptographic algorithm, the encryption and decryption keys are the same.
As seen in Figure 28, Ghidra is unable to identify the type of auStack_28 variable. However, it’s 8 characters long. The memcpy (line 9) is used to copy 8 bytes from memory location held in DAT_000c9f80 pointer. Possibly copying the encryption key. In Ghidra, we can navigate to the actual memory address and see its contents.
 
Figure 29: Lo and behold - that's the key 
Therefore, 478DA50FF9E3D2CB is the key. Now, that we have the key, we can use openssl command line utility or CyberChef web-based cryptographic tool to decrypt the couple of config files we have acquired.
 
Figure 30: Woohoo - the config file is decrypted and readable
As in Figure 30, des-ecb (Figured out using trial and error) is the DES mode used. By supplying the key, we can obtain the encrypted config file in plain text. Let’s start the hunt for credentials and other significant information.
 
Figure 31: Hunting for Credentials
Using grep to look for plain text username or password for the running service, there is nothing of value returned, unfortunately. But we learned about reverse engineering, Ghidra and cryptography 😊
Post-Exploitation
Lessons Learned
So far, we are able to investigate the IoT threat landscape. We gathered information about our target – TP-Link WR841NV14 router. In addition to scanning for open ports, we also acquired datasheets about the surface-mount chips. We were able to extract the firmware and dissect it to its sections. We located config files albeit encrypted. We managed to find the library responsible for encrypting the files and reverse-engineered to get the key and the algorithm used. We obtained the key and decrypted the files. Although no significant information was in the config files, we learned a lot.
Moving Forward
We can see UART port on the device. We will see if we can connect to it and read boot information or even open live shell.
